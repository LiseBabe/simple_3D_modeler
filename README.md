# Skeleton-based 3D Modeler

Authors : Katia BRENAUT and Lise BABÉ

Supervisor : Mr. Cédric ZANNI 

## The Project

The project subject was given by our tutor. The initial title was "skeleton-based 3D modeling." The aim of this project was to build a 3D modeling application using only bones and joints to create forms.

We used Capsule Sketch as a source of inspiration (https://capsulesketch.org). This source was provided by our tutor, who had the chance to contribute to this project. Capsule Sketch is a minimalist application that uses only spheres to represent joints and cones to represent bones, with just a few buttons for interaction.

We used the `Ray Tracing in One Weekend` tutorial by Peter Shirley, to build the very first structure of our application (https://raytracing.github.io). It helped us a lot to understand the concepts of Ray Tracing.

## Code Structure

### General Information
We decided to use C++ as the main language for this project. We made this decision based on the performance that C++ had shown in the past, and our tutor also advised us to use this language. We do not regret this choice as the resulting program is quite efficient.

To render the results of the calculations, we chose Python, as we had more experience with it relating to displaying graphical user interfaces. Initially, we decided to use TkInter (https://docs.python.org/fr/3/library/tkinter.html). We chose this because of our background with this library. In fact, during our studies, we had several opportunities to work with it, so we naturally chose it. After a few months, once the project was set up, we decided to switch to Taichi Lang (https://www.taichi-lang.org). Taichi Lang specializes in calculus optimization, as it parallelizes processes to optimize performance.

Obviously, we had to find a way to allow the Python script to communicate with the C++ script. To do so, we used a binding. A binding allows a language to access functions from another language. It is used in many ways whenever people need to use several programming languages. In our case, we used a binding to allow the Python script to interact with the C++ scripts and classes.
Initially, we used Nanobind (https://nanobind.readthedocs.io/en/latest/). Nanobind is great when you need to accelerate only a few tasks, but it is quite limited in functionalities. Nanobind is based on another library called PyBind11 (https://pybind11.readthedocs.io/en/stable/). Once the project was set up, we decided to switch to PyBind11. This library is older than Nanobind and offers more functionalities. The documentation is more comprehensive, which was very helpful during the project.

### Data Structure

The first step of the project was to determine the right way to store our data. Once a scene is set, we needed to interact easily with it. That is why we created the `linked_spheres_group` class. This class contains a vector of spheres and cones. The spheres are `sphere` objects from the `sphere` class, and the cones are `cone` objects from the `cone` class.

To access the data from the Python script, we decided to create the `modeler` class. The `modeler.cpp` file is used to implement the binding. Most of the functions of the class call the functions implemented in the `interactions` class. We decided to do this because it allows us to convert screen input into world input, for example, the coordinates on the screen into coordinates in the world. If we wanted to go further in the project, we could merge these two classes.

Once the scene is set, the camera from the `camera` class will calculate the image using the ray tracing method. This method will be explained in the next part.

We also have some classes such as `span3D` or `vec3` that are utility classes. We needed them in the project in order to have better data management.

### Rendering of the Image

To calculate the image resulting from the scene, we used the Ray Tracing method, which consists in finding interctions between rays launched from the camera and objects in the seen, to determine how the points of interception appears on screen (according to Peter Shirley's `Ray Tracing in One Weekend` tutorial.) 

Once the image is generated by the C++ script, we need to pass it to the Taichi method to display it. Taichi requires a numpy array of size (n, m, 3) with `n` and `m` being the dimensions of the window, and 3 being the number of color channels. Since we have set up a binding to exchange information between the C++ script and the Python one, we needed to find a way to exchange the color channel data between these two scripts. The problem here was that C++ does not have an object with the dimensions of the numpy array. We had to create an object that can replace the numpy array. The `span3D` class was created to solve this problem. The `span3D` class works just like the `span` class defined in C++, but it stores the numpy array continuously.

## How to use It 

### Run the Program

In order to run the Python file, you will require a specific setup:
- *CMake*: version `3.15` minimum, up to `3.27`
- *C++*: version `20`
- *Python*: any version of `python3`
- *Taichi Lang*: install with `pip install taichi -U`
- *Tkinter*: already in python3, if not install with `sudo apt-get install python3-tk`

Once your device is set up, you can run the program:
- Create a build directory with `mkdir build`
- Go to the build directory with `cd build`
- Call cmake with `cmake ..`
- Ask cmake to generate the files with `make`
- Once this is done, return to the main directory with `cd ..`
- Run the Python file with `python3 modeler.py`

NB: On Windows, with Clion IDE, in Cmake profiles, choose Visual Studio for the toolchain, and Ninja for the generator.

### List of Commands

The following lines describe each command you can operate once the application is running. 

Note: `LMB` is a shortcut for left mouse button

- You can move the camera: 
    - `UP`/`DOWN`/`LEFT`/`RIGHT`: camera rotates around the scene
    - `SHIFT` + `UP` / `SHIFT` + `DOWN`: camera moves forward and backward
    - `CONTROL`+ `UP`/`DOWN`/`LEFT`/`RIGHT`: camera moves in the specified direction

- You can select and unselect spheres: 
    - `LMB` + `click` *on sphere*: select one sphere
    - `CONTROL` + `LMB` + `click` *on sphere*: select several spheres
    - `Click` *on void*: unselect everything

- Once one or more spheres are selected: 
    - `E` + `LMB`: move sphere on the scene
    - `Q` + `LMB` *on sphere* (or `A` + `LMB` *on sphere* on an AZERTY keyboard): add a sphere at the surface of the one behind
    - `Q` + `LMB` *on cone* (or `A` + `LMB` *on cone* on an AZERTY keyboard): add a sphere inside the cone, without modifying the shape of the cone
    - `D`: delete sphere
    - `C`: open the color picker box
    - `R` + `LMB`: increase/decrease the radius
    - `SHIFT` + `R`: open a dialog box to set the radius
    - `F`: link two selected spheres
    - `A` or `S` (or `Q` or `S` on an AZERTY keyboard): rotate selected sphere around the camera axis, 2 or more spheres need to be selected
    - `O` or `P`: rotate selected sphere around an axis defined by the first two spheres selected, 3 or more spheres need to be selected
    - `K` + `LMB`: move spheres with inverse kinematic movement, 3 or more spheres need to be selected 

- Other commands:
    - `W` (or `Z` on an AZERTY keyboard): make the skeleton visible/invisible
    - `SHIFT` + `S`: open the file manager of your device to save the scene into a text file
    - `SHIFT` + `L`: open the file manager of your device to load a scene from a text file
